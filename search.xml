<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「数据结构和算法」3.保留最后加入的固定个数的元素]]></title>
    <url>%2F2018%2F03%2F08%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D3-%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E%E5%8A%A0%E5%85%A5%E7%9A%84%E5%9B%BA%E5%AE%9A%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[问题描述在迭代操作或者其他操作的时候，怎样只保留最后加入的固定个数的元素？ 解决方案使用 collections.deque(maxlen=N) 建立固定大小的队列，当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。 如： 12345678910111213141516def test_deque_maxlen(): """测试如何使用固定大小的队列""" q = deque(maxlen=3) # 新建一个固定大小的队列 q.append(1) # 添加元素 q.append(2) q.append(3) assert list(q) == [1, 2, 3] # 正好添加3个 # 再添加2个 q.append(4) q.append(5) # 会把老的元素移除 assert list(q) == [3, 4, 5] 举个例子： 假设现在有一个文件，我们遍历文件的每一行，但是保留最后读取的 5 行内容，应该如何做呢？ 示例代码： 12345678910111213141516171819202122232425262728293031323334353637import osfrom collections import dequerelative_path = "somefile.txt"filepath = os.path.join(os.path.dirname(os.path.realpath(__file__)), os.sep.join(relative_path.split('/')))def search(lines, pattern, history=5): """ 搜索关键字内容，返回最后读取的5行内容 :param lines: 一行内容 :param pattern: 匹配的关键字 :param history: 用于生成固定队列的大小 :return: """ previous_lines = deque(maxlen=history) # 使用 deque 新建一个固定大小的队列 for line in lines: if pattern in line: yield line, previous_lines # 返回一个迭代器 previous_lines.append(line)def test_last_n(): with open(filepath) as f: # 遍历迭代器 search for line, prevlines in search(f, 'Python', 5): # prevlines 首次返回的是空，因此跳过去 if prevlines: assert len(prevlines) == 5 # 其余情况一定是固定的5个元素 # 遍历 previous_lines for pline in prevlines: print(pline, end='') # 打印出来 print('-' * 20) 我们在写查询元素的代码时，通常会使用包含 yield 表达式的生成器函数，这样可以将搜索过程代码和使用搜索结果代码解耦。]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」2.解压可迭代对象赋值给多个变量]]></title>
    <url>%2F2018%2F03%2F07%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D2-%E8%A7%A3%E5%8E%8B%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[问题描述如果我们遇到一个不确定个数的可迭代对象，如何解压它们呢？ 如果直接用变量解压，变量个数超过元素个数时，会抛出一个 ValueError 。 如： 12345# 变量个数超过元素&gt;&gt;&gt; a,b,c,d = [1,2]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: not enough values to unpack (expected 4, got 2) 那么怎样才能从这个可迭代对象中解压出想要的元素来呢？ 解决方案Python 的星号表达式可以用来解决这个问题。 示例1：星号表达式用在中间部分 你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，但是需要排除掉第一个和最后一个分数，如何实现呢？ 如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有 24 个呢？ 这时候星号表达式就派上用场了。 代码演示： 12345678def test_use_asterisk_expr(): grades = (30, 40, 60, 80, 90, 98, 100) # 使用*号表达式 first, *middle, last = grades assert middle == [40, 60, 80, 90, 98] assert 73.6 == sum(middle) / len(middle) 示例2：星号表达式用在后面的部分 假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 如： 12&gt; record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')&gt; 如何分解这些记录呢？ 代码演示： 12345678910def test_use_asterisk_expr_behind(): record = ('张三', 'dave@example.com', '773-555-1212', '847-555-1212') # 使用星号表达式 name, email, *phone_numbers = record assert name == "张三" assert email == 'dave@example.com' # 解压出的 phone_numbers 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个） assert phone_numbers == ['773-555-1212', '847-555-1212'] 注意： 上面解压出的 phone_numbers 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个）。 所以，任何使用到 phone_numbers 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。 示例3：星号表达式用在前面的部分 假设你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。 如： 12&gt; datas = [10, 8, 7, 1, 9, 5, 10, 3]&gt; 如何获得最近1个和前面7个数据呢？ 代码演示： 1234567def test_use_asterisk_expr_front(): datas = [10, 8, 7, 1, 9, 5, 10, 3] *trailing, last = datas assert trailing == [10, 8, 7, 1, 9, 5, 10] assert last == 3 更多讨论 扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 在什么时候使用星号表达式呢？ 当可迭代对象的元素结构有确定的规则的（比如第 1 个元素后面都是电话号码），星号表达式让我们可以很容易的利用这些规则来解压出元素来， 而不是通过一些比较复杂的手段去获取这些关联的元素值。 遍历可变的长元组序列值得注意的是，星号表达式在迭代元素为可变的长元组序列时是很有用的。 示例代码： 1234567891011121314151617181920def test_var_long_tuple(): # 一个可变长元组的序列 records = [ ('foo', 1, 2), ('bar', 'hello'), ('foo', 3, 4), ] def do_foo(x, y): print('foo:', x, y) def do_bar(s): print('bar:', s) # 使用星号表达式遍历一个可变长元组的序列 for tag, *args in records: if tag == 'foo': do_foo(*args) elif tag == 'bar': do_bar(*args) 字符串的分割星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。 示例代码： 123456def test_separate_str(): line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false' uname, *fields, homedir, sh = line.split(':') assert uname == "nobody" assert homedir == "/var/empty" assert sh == "/usr/bin/false" 解压一些元素后丢弃有时候，我们想解压一些元素后丢弃它们，虽然不能简单就使用 * ， 但是可以使用一个普通的废弃名称，比如 _ 或者 ign （ignore）。 示例代码： 12345def test_ignore(): record = ('ACME', 50, 123.45, (12, 18, 2012)) name, *_, (*_, year) = record assert name == 'ACME' assert year == 2012 分隔列表在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。 比如，如果你有一个列表， 你可以很容易的将它分割成几部分。 示例代码： 123456789101112131415161718def test_use_asterisk_expr(): grades = (30, 40, 60, 80, 90, 98, 100) # 在中间使用星号表达式 first, *middle, last = grades assert first == 30 assert middle == [40, 60, 80, 90, 98] assert last == 100 # 在后边使用星号表达式 first, *behind= grades assert first == 30 assert behind == [40, 60, 80, 90, 98, 100] # 在前边使用星号表达式 *front, last = grades assert front == [30, 40, 60, 80, 90, 98] assert last == 100]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何修改macOS上的命令提示符]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9macOS%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[命令提示符是什么？当我们打开一个终端时首先看到的就是 Bash 命令提示符，格式为： 1用户名@主机名 ~$ 例如： 1bixiaopeng@bixiaopengtekiMacBook-Pro ~$ 查看主机名： 12$ hostnamebixiaopengtekiMacBook-Pro.local 这个提示符太长了，我想修改一下怎么改呢？ 修改命令提示符默认情况下，Bash 命令提示符中最长的就是主机名，我们一起来看一下怎么修改。 修改主机名把主机名改为 macOS： 12$ sudo scutil --set HostName macOSPassword:(输入密码) 新打开一个终端窗口修改才会生效，效果为： 1bixiaopeng@macOS ~$ 配置提示符一些必要的说明Bash 命令提示符是通过环境变量PS1（Prompt String 1） 来设置的，查看现有的设置： 12bixiaopeng@macOS ~$ echo $PS1\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] 效果是这样的： \[\033[01;33m\] 是颜色，去掉配置的颜色，看得会更清晰一些： 1\u@\h \W\$ 翻译为： 1用户名@主机名 当前工作目录名称$ 配置参数的解释： 12345678\u：用户名\h：主机名\w：当前所在工作目录路径\W：当前工作目录名称，~ 表示主目录\t：当前时间\n：换行\D&#123;%c&#125;：获取本地化的日期和时间\$：使用 $ 作为提示符，如果 root 过的话，则显示 # 尝试配置自己的提示符12345$ PS1="\u@\h \W\$"bixiaopeng@macOS ~$# 给点颜色bixiaopeng@macOS ~$ PS1="\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] " 效果如下图所示： 上面的命令都可以看作是效果的预览，如果想让配置真正的生效，还需要 export 一下： 12# 接上述命令bixiaopeng@macOS ~$ export PS1 或在接在 ~/.bash_profile 中修改配置： 1export PS1="\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] "]]></content>
      <categories>
        <category>了不起的macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞清楚Python中的模块-包-库-应用程序]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%90%9E%E6%B8%85%E6%A5%9APython%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97-%E5%8C%85-%E5%BA%93-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Python 中经常会有一些名词让我们感觉似懂非懂，比如：模块（Module）、包（Package）、库（Library）、应用（Application）、框架（Framework），它们是什么？有什么关系？有什么不同？ 今天我们来梳理清楚。 先来看一个项目结构的例子： 1234567├── myapp # 包含 __init__.py 文件的文件夹都叫做包(package)│ ├── __init__.py│ └── utils.py # .py 文件都称为模块(module)├── setup.py├── tests│ ├── __init__.py│ ├── test_help.py 说明： 包含 __init__.py 文件的文件夹叫做「包」，如 requests 和 tests； 所有 .py 文件都叫「模块」，如：__init__.py 和 utils.py； 所有这些代码组成了一个「应用程序」，用于完成某项或多项特定的工作； 本质上「库」、「框架」都是「应用程序」，只不过因为使用场景、提供的功能和解决问题的复杂度有所区分。 来张图可能会更直观一些： 可以再简单一点的理解为： 「函数」和「类」组成了「模块」，多个「模块」组成了「包」，多个「包」或者多个「模块」组成了「应用程序」，「应用程序」具有某些特定功能且作为依赖提供给其他项目使用叫作「库」，提供某一领域解决方案的「库」叫框架。 总结一下： 名词 英文 解释 模块 Module .py 文件都称叫模块。 包 Package 包含 __init__.py 文件的文件夹叫做包。 应用程序 Application 应用程序是完成某项或多项特定功能的代码集合，由包和模块组成。 库 Library 发布在 PYPI 上供他人使用的应用程序叫第三方库，Python 内置的叫标准库，库一般用于解决特定问题，如：requests、sh、arrow、pipenv。 框架 Framework 为解决某一特殊领域的问题而设计的具有一定约束性和支撑性的库叫框架，如 Flask、Django、Selenium、Tensorflow。]]></content>
      <categories>
        <category>品味Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」1.解压序列然后赋值给多个变量]]></title>
    <url>%2F2018%2F01%2F21%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D1-%E8%A7%A3%E5%8E%8B%E5%BA%8F%E5%88%97%E7%84%B6%E5%90%8E%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[问题描述有一个元组或序列包含了 N 个元素，如：a_list = [4, 5, 6] 如何将它里面的值解压后同时赋值给 N 个变量呢？ 解决方案任何一个序列（或者可迭代的对象）都可以通过一个简单的赋值语句解压并赋值给多个变量。 不过，需要注意的一个前提就是：变量的个数必须跟序列元素的个数相同。 实例演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 校验把一个「元组」解压并赋值给多个变量def test_unzip_assign_a_tuple(): a_tuple = (1, 2, 3) # 元组 # 把元组解压并赋值给3个变量 t1, t2, t3 = a_tuple assert t1 == 1 assert t2 == 2 assert t3 == 3# 校验把一个「列表」解压并赋值给多个变量def test_unzip_assign_a_list(): # 列表 a_list = [4, 5, 6] # 把列表解压并赋值给3个变量 l1, l2, l3 = a_list assert l1 == 4 assert l2 == 5 assert l3 == 6# 校验把一个「字符串」解压并赋值给多个变量def test_unzip_assign_a_str(): # 字符串 a_str = "fan" # 把字符串解压并赋值给3个变量 s1, s2, s3 = a_str assert s1 == "f" assert s2 == "a" assert s3 == "n"# 校验把一个「混合列表」解压并赋值给多个变量def test_unzip_assign_a_mix_list(): # 混合的列表 mix_list = [4, 5, 'bi', (2018, 1, 21)] # 把混合的列表解压并赋值给4个变量 m1, m2, m3, m4 = mix_list assert m1 == 4 assert m2 == 5 assert m3 == 'bi' assert m4 == (2018, 1, 21) # 把混合的列表解压并赋值给6个变量 m1, m2, m3, (m4, m5, m6) = mix_list assert m1 == 4 assert m2 == 5 assert m3 == 'bi' assert m4 == 2018 assert m5 == 1 assert m6 == 21# 校验把生成器解压并赋值给多个变量def test_unzip_assign_generator(): a_generator = (x * 2 for x in range(3)) g1, g2, g3 = a_generator assert g1 == 0 assert g2 == 2 assert g3 == 4 如果我们只想获取一个列表中的一部分值，其他的值并不关心，怎么办呢？ 123456# 校验只解压一部分值并赋值给变量def test_unzip_part(): # 把不关心的变量使用一些变量占位，这样就可以只获取关心的变量了 _, name, _, gender = [1, "bixiaofan", 2, "帅哥"] assert name == "bixiaofan" assert gender == "帅哥" 注意：必须要保证用于占位的变量在其他地方没有被使用。 小贴示： 这种解压赋值可以用在任何可迭代的对象上，不仅限于列表、元组和字符串，文件对象、迭代器和生成器也是可以的。]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[显示命令的帮助手册-man]]></title>
    <url>%2F2018%2F01%2F21%2F%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C-man%2F</url>
    <content type="text"><![CDATA[man 是 manual（手册）的缩写，用来快速查询某个命令的 man-pages（帮助手册页面），并格式化显示。 常用方法:1234567891011# 显示某个命令的帮助手册$ man 命令名# 显示某个命令帮助手册的位置而不是内容：$ man -w 命令名# 显示帮助手册的搜索路径$ man --path# 查询所有包含某个关键字的帮助手册$ man -k 关键字 实例演示:实例1：显示 sort 命令的帮助手册1~$ man sort 命令执行后会进入帮助手册页面，如图所示。帮助手册页面包括了命令的介绍和用法，以及命令选项的说明。 帮助手册页面其实是进入了less查看模式，只要使用less的快捷键操作来查看页面就可以了，非常方便。 实例2：显示man命令查找帮助手册的路径123456~$ man --path/opt/subversion/man:/Library/Frameworks/Python.framework/Versions/2.7/share/man:/usr/local/share/man:/usr/share/man:/opt/X11/share/man:/Applications/Xcode.app/Contents/Developer/usr/share/man:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/share/man# 或 使用man -w,后面不带参数哦。~$ man -w/opt/subversion/man:/Library/Frameworks/Python.framework/Versions/2.7/share/man:/usr/local/share/man:/usr/share/man:/opt/X11/share/man:/Applications/Xcode.app/Contents/Developer/usr/share/man:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/share/man 实例3：显示 ssh 命令的帮助手册地址12~$ man -w ssh/usr/share/man/man1/ssh.1 实例4：查询所有包含 awk 的帮助手册1234~$ man -k awkEnglish(3pm) - use nice English (or awk) names for ugly punctuation variablesa2p(1) - Awk to Perl translatorawk(1) - pattern-directed scanning and processing language]]></content>
      <categories>
        <category>每天一个Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
