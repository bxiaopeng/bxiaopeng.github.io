<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「数据结构和算法」7-字典排序]]></title>
    <url>%2F2018%2F04%2F07%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D7-%E5%AD%97%E5%85%B8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题描述假如我们想创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。如何实现呢？ 解决方案为了能控制字典中元素的顺序，我们可以使用 collections 模块中的 OrderedDict 类。 在迭代操作的时候 OrderedDict 会保持元素被插入时的顺序。 代码示例： 1234567891011121314151617181920212223from collections import OrderedDictimport jsondef test_ordereddict(): """使用OrderedDict保持字典中元素的顺序""" od = OrderedDict() # 向字典中插入元素 od['one'] = 1 od['two'] = 2 od['three'] = 3 od['four'] = 4 # 获取字典的值时，顺序没变哦 assert list(od.values()) == [1, 2, 3, 4] # 遍历时,顺序也是没变的哦 for key in od: print(key, od[key]) # 序列化时顺序也是保持不变的 assert json.dumps(od) == &#123;"one": 1, "two": 2, "three": 3, "four": 4&#125; 从上面的例子可以看出，如果我们想精确控制使用 JSON 编码后「字段的顺序」，可以使用 OrderedDict 来构建这样的数据。 扩展讨论OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。 每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。 需要注意的是， 一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。 所以如果你要构建一个需要大量 OrderedDict 实例的数据结构的时候（比如读取 100,000 行 CSV 数据到一个 OrderedDict 列表中去）， 那么你就得仔细权衡一下是否使用 OrderedDict 带来的好处要大过额外内存消耗的影响。]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」6-字典中的键映射多个值]]></title>
    <url>%2F2018%2F04%2F04%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D6-%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E9%94%AE%E6%98%A0%E5%B0%84%E5%A4%9A%E4%B8%AA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[问题描述怎样实现一个键对应多个值的字典（也叫 multidict）？ 解决方案我们都知道一个字典就是一个键对应一个单值的映射。 如：{&quot;one&quot;:1} 可如果我们想要让一个键映射多个值，那么就需要将这多个值放到另外的容器（列表或集合）中。 如：{&quot;one&quot;:[1,2,3,4]} 选择使用列表还是集合取决于你的实际需求。 如果你想保持元素的插入顺序就应该使用列表。 如果想去掉重复元素就使用集合（并且不关心元素的顺序）。 使用 defaultdict我们可以很方便的使用 collections 模块中的 defaultdict 来构造这样的字典。 defaultdict 的一个特征是它会自动初始化每个 key 刚开始对应的值，所以我们只需要关注添加元素操作就行了。 比如： 12345678910111213141516171819202122232425262728293031from collections import defaultdictdef test_multidict_use_defaultdict(): """使用defaultdict创建多值字典""" # 用列表来存储多个值，会保持元素的插入顺序，且不会去掉重复的元素 d = defaultdict(list) # 向「键」中加入多个值 d['name'].append("张三") d['name'].append("李四") d['name'].append("王二") d['name'].append("王二") d['age'].append(20) assert d.get('name') == ['张三', '李四', '王二', '王二'] assert d.get('age') == [20] # 用集合来存储多个值，会去掉重复的元素，且不关心元素顺序 d2 = defaultdict(set) d2['name'].add("张三") d2['name'].add("李四") d2['name'].add("王二") d2['name'].add("王二") d2['name'].add("王二") d2['name'].add("王二") d2['age'].add(20) assert d2.get('name') == &#123;'李四', '张三', '王二'&#125; assert d2.get('age') == &#123;20&#125; 需要注意的是， defaultdict 会自动为将要访问的键（就算目前字典中并不存在这样的键）创建映射实体。 如果我们不需要这样的特性，可以在一个普通的字典上使用 setdefault() 方法来代替。 使用 setdefault使用setdefault创建多值字典，比如： 12345678910def test_multidict_use_setdefault(): """使用setdefault创建多值字典""" d = &#123;&#125; # 一个普通的字典 d.setdefault('a', []).append(1) # 每次都要创建一个新的初始值实例 d.setdefault('a', []).append(2) d.setdefault('b', []).append(4) assert d.get('a') == [1, 2] assert d.get('b') == [4] 但是很多程序员觉得 setdefault() 用起来有点别扭。因为每次调用都得创建一个新的初始值的实例（例子程序中的空列表 [] ）。 自已动手一般来讲，创建一个多值映射字典是很简单的。 但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦。 你可能会像下面这样来实现： 12345d = &#123;&#125;for key, value in pairs: if key not in d: d[key] = [] d[key].append(value) 如果使用 defaultdict 的话代码就更加简洁了： 123d = defaultdict(list)for key, value in pairs: d[key].append(value)]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」5-实现一个优先级队列]]></title>
    <url>%2F2018%2F04%2F03%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D5-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[问题描述怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素？ 解决方案可使用 heapq 模块实现了一个简单的优先级队列。 代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import heapqclass PriorityQueue: """利用 heapq 模块实现了一个简单的优先级队列""" def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): """ 添加队列 :param item: 元素 :param priority: 优先级 """ # 优先级为负数的目的是使得元素按照优先级从高到低排序 # 这个跟普通的按优先级从低到高排序的堆排序恰巧相反 heapq.heappush(self._queue, (-priority, self._index, item)) # 通过不断增加 index 保证元素按照它们插入的顺序挺排序 self._index += 1 def pop(self): """弹出队列""" return heapq.heappop(self._queue)[-1]class Item: """使用方式""" def __init__(self, name): self.name = name def __repr__(self): return 'Item(&#123;!r&#125;)'.format(self.name)def test_priority_queue(): q = PriorityQueue() # 插入元素 q.push(Item('foo'), 1) q.push(Item('bar'), 5) q.push(Item('spam'), 4) q.push(Item('grok'), 1) # 按优先级 pop 元素 print(q.pop()) # Item('bar') print(q.pop()) # Item('spam') # 如果优先级相同，则按插入顺序返回 print(q.pop()) # Item('foo') print(q.pop()) # Item('grok') 函数 heapq.heappush() 和 heapq.heappop() 分别在队列 _queue 上插入和删除第一个元素， 并且队列 _queue 保证第一个元素拥有最高优先级。 heappop() 函数总是返回「最小的」的元素，这就是保证队列 pop 操作返回正确元素的关键。 另外，由于 push 和 pop 操作时间复杂度为 O(log N)，其中 N 是堆的大小，因此就算是 N 很大的时候它们运行速度也依旧很快。 在上面代码中，队列包含了一个 (-priority, index, item) 的元组。 优先级为负数（-priority）的目的是使得元素按照优先级从高到低排序。 这个跟普通的按优先级从低到高排序的堆排序恰巧相反。 index 变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的 index 下标变量，可以确保元素按照它们插入的顺序排序。 而且， index 变量也在相同优先级元素比较的时候起到重要作用。 Tips: 如果我们想在多个线程中使用同一个队列，就需要增加适当的锁和信号量机制。]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「类与对象」1-改变对象实例的字符串显示]]></title>
    <url>%2F2018%2F04%2F03%2F%E3%80%8C%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%8D1-%E6%94%B9%E5%8F%98%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[问题描述如果我们想改变对象实例的打印或显示输出，让它们更具可读性，应该怎么做呢？ 解决方案想要改变一个对象实例的字符串显示，可重新定义它的 __str__() 和 __repr__() 方法。 代码演示： 12345678910class Pair: def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return 'Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)'.format(self) def __str__(self): return '(&#123;0.x!s&#125;, &#123;0.y!s&#125;)'.format(self) __repr__() 方法返回一个实例的代码表示形式，通常用来重新构造这个实例。 内置的 repr() 函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。 __str__() 方法将实例转换为一个字符串，使用 str() 或 print() 函数会输出这个字符串。 简而言之： 如果要把一个实例通过 print 显示成字符串，就要实现 __str__()，如果要在交互命令行下直接通过调用实例显示，就要实现 __repr__() 。 代码示例： 123456&gt;&gt;&gt; p = Pair(3, 4)&gt;&gt;&gt; pPair(3, 4) # 输出的是 __repr__() &gt;&gt;&gt; print(p)(3, 4) # 输出的是 __str__() &gt;&gt;&gt; 扩展讨论为何要自定义 __repr__() 和 __str__() ？自定义 __repr__() 和 __str__() 通常是很好的习惯，因为它能简化调试和实例输出。 例如，对于某个对象的实例，如果我们仅仅只是打印输出或日志输出，那么我们就会看到更加详细与有用的实例信息。 简而言之： __repr__() 是给程序员看的。 __str__() 是给用户看的。 几种格式化方法上面的例子中我们还演示了在格式化的时候怎样使用不同的字符串表现形式。 !r 格式化代码!r 格式化代码指明输出使用 __repr__() 来代替默认的 __str__() 。 用前面的类来测试一下： 123456&gt;&gt;&gt; p = Pair(3, 4)&gt;&gt;&gt; print('p is &#123;0!r&#125;'.format(p))p is Pair(3, 4) # 使用 !r 格式化后输出的是 __repr__()&gt;&gt;&gt; print('p is &#123;0&#125;'.format(p))p is (3, 4) # 没有格式化的默认输出是 __str__()&gt;&gt;&gt; {0.x} 格式化代码上面的 format() 方法的使用看上去很有趣，格式化代码 {0.x} 对应的是第 1 个参数的 x 属性。 因此，在下面的方法中，0 实际上指的就是 self 本身。 示例代码： 12def __repr__(self): return 'Pair(&#123;0.x!r&#125;, &#123;0.y!r&#125;)'.format(self) % 格式化代码作为上面这种实现的一个替代，我们也可以使用 % 操作符。 示例代码： 12def __repr__(self): return 'Pair(%r, %r)' % (self.x, self.y)]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」4-查找最大或最小的N个元素]]></title>
    <url>%2F2018%2F03%2F13%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D4-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E6%88%96%E6%9C%80%E5%B0%8F%E7%9A%84%20N%20%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[问题描述怎样从一个集合中获得最大或者最小的 N 个元素列表？ 解决方案heapq 模块有两个函数：nlargest() 和 nsmallest() 可以完美解决这个问题。 示例代码： 12345678def test_nlargest_nsmallest(): li = [3, 8, 4, 5, 9, 0, 2, 6] heapq.heapify(li) # 获得n个最大的元素 assert heapq.nlargest(3, li) == [9, 8, 6] # 获得n个最小的元素 assert heapq.nsmallest(3, li) == [0, 2, 3] 两个函数都能接受一个关键字参数，用于更复杂的数据结构中： 123456789101112131415161718192021222324def test_heapq_nsmallest_nlargest(): portfolio = [ &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;, &#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;, &#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;, &#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125;, &#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;, &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125; ] # 以 price 的值进行比较，取最小的3个 cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price']) assert cheap == [ &#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;, &#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;, &#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125; ] # 以 price 的值进行比较，取最大的3个 expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price']) assert expensive == [ &#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;, &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;, &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125; ] 扩展讨论如果你想在一个集合中查找最小或最大的 N 个元素，并且 N 小于集合元素数量，那么这些函数提供了很好的性能。 因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中： 1234567&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = list(nums)&gt;&gt;&gt; heapq.heapify(heap)&gt;&gt;&gt; heap[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] # heap[0] 永远是最小的元素&gt;&gt;&gt; 堆数据结构最重要的特征是 heap[0] 永远是最小的元素。 并且剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。 比如，如果想要查找最小的 3 个元素，你可以这样做： 123456&gt;&gt;&gt; heapq.heappop(heap)-4&gt;&gt;&gt; heapq.heappop(heap)1&gt;&gt;&gt; heapq.heappop(heap)2 当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的。 如果你仅仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 min() 和 max() 函数会更快些。 类似的， 如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （ sorted(items)[:N] 或者是 sorted(items)[-N:] ）。 需要在正确场合使用函数 nlargest() 和 nsmallest() 才能发挥它们的优势 （如果 N 快接近集合大小了，那么使用排序操作会更好些）。 尽管你没有必要一定使用这里的方法，但是堆数据结构的实现是一个很有趣并且值得你深入学习的东西。 基本上只要是数据结构和算法书籍里面都会有提及到。]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」3.保留最后加入的固定个数的元素]]></title>
    <url>%2F2018%2F03%2F08%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D3-%E4%BF%9D%E7%95%99%E6%9C%80%E5%90%8E%E5%8A%A0%E5%85%A5%E7%9A%84%E5%9B%BA%E5%AE%9A%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[问题描述在迭代操作或者其他操作的时候，怎样只保留最后加入的固定个数的元素？ 解决方案使用 collections.deque(maxlen=N) 建立固定大小的队列，当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。 如： 12345678910111213141516def test_deque_maxlen(): """测试如何使用固定大小的队列""" q = deque(maxlen=3) # 新建一个固定大小的队列 q.append(1) # 添加元素 q.append(2) q.append(3) assert list(q) == [1, 2, 3] # 正好添加3个 # 再添加2个 q.append(4) q.append(5) # 会把老的元素移除 assert list(q) == [3, 4, 5] 举个例子： 假设现在有一个文件，我们遍历文件的每一行，但是保留最后读取的 5 行内容，应该如何做呢？ 示例代码： 12345678910111213141516171819202122232425262728293031323334353637import osfrom collections import dequerelative_path = "somefile.txt"filepath = os.path.join(os.path.dirname(os.path.realpath(__file__)), os.sep.join(relative_path.split('/')))def search(lines, pattern, history=5): """ 搜索关键字内容，返回最后读取的5行内容 :param lines: 一行内容 :param pattern: 匹配的关键字 :param history: 用于生成固定队列的大小 :return: """ previous_lines = deque(maxlen=history) # 使用 deque 新建一个固定大小的队列 for line in lines: if pattern in line: yield line, previous_lines # 返回一个迭代器 previous_lines.append(line)def test_last_n(): with open(filepath) as f: # 遍历迭代器 search for line, prevlines in search(f, 'Python', 5): # prevlines 首次返回的是空，因此跳过去 if prevlines: assert len(prevlines) == 5 # 其余情况一定是固定的5个元素 # 遍历 previous_lines for pline in prevlines: print(pline, end='') # 打印出来 print('-' * 20) 我们在写查询元素的代码时，通常会使用包含 yield 表达式的生成器函数，这样可以将搜索过程代码和使用搜索结果代码解耦。]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」2.解压可迭代对象赋值给多个变量]]></title>
    <url>%2F2018%2F03%2F07%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D2-%E8%A7%A3%E5%8E%8B%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[问题描述如果我们遇到一个不确定个数的可迭代对象，如何解压它们呢？ 如果直接用变量解压，变量个数超过元素个数时，会抛出一个 ValueError 。 如： 12345# 变量个数超过元素&gt;&gt;&gt; a,b,c,d = [1,2]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: not enough values to unpack (expected 4, got 2) 那么怎样才能从这个可迭代对象中解压出想要的元素来呢？ 解决方案Python 的星号表达式可以用来解决这个问题。 示例1：星号表达式用在中间部分 你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，但是需要排除掉第一个和最后一个分数，如何实现呢？ 如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有 24 个呢？ 这时候星号表达式就派上用场了。 代码演示： 12345678def test_use_asterisk_expr(): grades = (30, 40, 60, 80, 90, 98, 100) # 使用*号表达式 first, *middle, last = grades assert middle == [40, 60, 80, 90, 98] assert 73.6 == sum(middle) / len(middle) 示例2：星号表达式用在后面的部分 假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 如： 12&gt; record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')&gt; 如何分解这些记录呢？ 代码演示： 12345678910def test_use_asterisk_expr_behind(): record = ('张三', 'dave@example.com', '773-555-1212', '847-555-1212') # 使用星号表达式 name, email, *phone_numbers = record assert name == "张三" assert email == 'dave@example.com' # 解压出的 phone_numbers 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个） assert phone_numbers == ['773-555-1212', '847-555-1212'] 注意： 上面解压出的 phone_numbers 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个）。 所以，任何使用到 phone_numbers 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。 示例3：星号表达式用在前面的部分 假设你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。 如： 12&gt; datas = [10, 8, 7, 1, 9, 5, 10, 3]&gt; 如何获得最近1个和前面7个数据呢？ 代码演示： 1234567def test_use_asterisk_expr_front(): datas = [10, 8, 7, 1, 9, 5, 10, 3] *trailing, last = datas assert trailing == [10, 8, 7, 1, 9, 5, 10] assert last == 3 更多讨论 扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 在什么时候使用星号表达式呢？ 当可迭代对象的元素结构有确定的规则的（比如第 1 个元素后面都是电话号码），星号表达式让我们可以很容易的利用这些规则来解压出元素来， 而不是通过一些比较复杂的手段去获取这些关联的元素值。 遍历可变的长元组序列值得注意的是，星号表达式在迭代元素为可变的长元组序列时是很有用的。 示例代码： 1234567891011121314151617181920def test_var_long_tuple(): # 一个可变长元组的序列 records = [ ('foo', 1, 2), ('bar', 'hello'), ('foo', 3, 4), ] def do_foo(x, y): print('foo:', x, y) def do_bar(s): print('bar:', s) # 使用星号表达式遍历一个可变长元组的序列 for tag, *args in records: if tag == 'foo': do_foo(*args) elif tag == 'bar': do_bar(*args) 字符串的分割星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。 示例代码： 123456def test_separate_str(): line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false' uname, *fields, homedir, sh = line.split(':') assert uname == "nobody" assert homedir == "/var/empty" assert sh == "/usr/bin/false" 解压一些元素后丢弃有时候，我们想解压一些元素后丢弃它们，虽然不能简单就使用 * ， 但是可以使用一个普通的废弃名称，比如 _ 或者 ign （ignore）。 示例代码： 12345def test_ignore(): record = ('ACME', 50, 123.45, (12, 18, 2012)) name, *_, (*_, year) = record assert name == 'ACME' assert year == 2012 分隔列表在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。 比如，如果你有一个列表， 你可以很容易的将它分割成几部分。 示例代码： 123456789101112131415161718def test_use_asterisk_expr(): grades = (30, 40, 60, 80, 90, 98, 100) # 在中间使用星号表达式 first, *middle, last = grades assert first == 30 assert middle == [40, 60, 80, 90, 98] assert last == 100 # 在后边使用星号表达式 first, *behind= grades assert first == 30 assert behind == [40, 60, 80, 90, 98, 100] # 在前边使用星号表达式 *front, last = grades assert front == [30, 40, 60, 80, 90, 98] assert last == 100]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何修改macOS上的命令提示符]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9macOS%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[命令提示符是什么？当我们打开一个终端时首先看到的就是 Bash 命令提示符，格式为： 1用户名@主机名 ~$ 例如： 1bixiaopeng@bixiaopengtekiMacBook-Pro ~$ 查看主机名： 12$ hostnamebixiaopengtekiMacBook-Pro.local 这个提示符太长了，我想修改一下怎么改呢？ 修改命令提示符默认情况下，Bash 命令提示符中最长的就是主机名，我们一起来看一下怎么修改。 修改主机名把主机名改为 macOS： 12$ sudo scutil --set HostName macOSPassword:(输入密码) 新打开一个终端窗口修改才会生效，效果为： 1bixiaopeng@macOS ~$ 配置提示符一些必要的说明Bash 命令提示符是通过环境变量PS1（Prompt String 1） 来设置的，查看现有的设置： 12bixiaopeng@macOS ~$ echo $PS1\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] 效果是这样的： \[\033[01;33m\] 是颜色，去掉配置的颜色，看得会更清晰一些： 1\u@\h \W\$ 翻译为： 1用户名@主机名 当前工作目录名称$ 配置参数的解释： 12345678\u：用户名\h：主机名\w：当前所在工作目录路径\W：当前工作目录名称，~ 表示主目录\t：当前时间\n：换行\D&#123;%c&#125;：获取本地化的日期和时间\$：使用 $ 作为提示符，如果 root 过的话，则显示 # 尝试配置自己的提示符12345$ PS1="\u@\h \W\$"bixiaopeng@macOS ~$# 给点颜色bixiaopeng@macOS ~$ PS1="\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] " 效果如下图所示： 上面的命令都可以看作是效果的预览，如果想让配置真正的生效，还需要 export 一下： 12# 接上述命令bixiaopeng@macOS ~$ export PS1 或在接在 ~/.bash_profile 中修改配置： 1export PS1="\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] "]]></content>
      <categories>
        <category>了不起的macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞清楚Python中的模块-包-库-应用程序]]></title>
    <url>%2F2018%2F01%2F24%2F%E6%90%9E%E6%B8%85%E6%A5%9APython%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97-%E5%8C%85-%E5%BA%93-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Python 中经常会有一些名词让我们感觉似懂非懂，比如：模块（Module）、包（Package）、库（Library）、应用（Application）、框架（Framework），它们是什么？有什么关系？有什么不同？ 今天我们来梳理清楚。 先来看一个项目结构的例子： 1234567├── myapp # 包含 __init__.py 文件的文件夹都叫做包(package)│ ├── __init__.py│ └── utils.py # .py 文件都称为模块(module)├── setup.py├── tests│ ├── __init__.py│ ├── test_help.py 说明： 包含 __init__.py 文件的文件夹叫做「包」，如本例中的 myapp 和 tests； 所有 .py 文件都叫「模块」，如：__init__.py 和 utils.py； 所有这些代码组成了一个「应用程序」，用于完成某项或多项特定的工作； 本质上「库」、「框架」都是「应用程序」，只不过因为使用场景、提供的功能和解决问题的复杂度有所区分。 来张图可能会更直观一些： 可以再简单一点的理解为： 「函数」和「类」组成了「模块」，多个「模块」组成了「包」，多个「包」或者多个「模块」组成了「应用程序」，「应用程序」具有某些特定功能且作为依赖提供给其他项目使用叫作「库」，提供某一领域解决方案的「库」叫框架。 总结一下： 名词 英文 解释 模块 Module .py 文件都称叫模块。 包 Package 包含 __init__.py 文件的文件夹叫做包。 应用程序 Application 应用程序是完成某项或多项特定功能的代码集合，由包和模块组成。 库 Library 发布在 PYPI 上供他人使用的应用程序叫第三方库，Python 内置的叫标准库，库一般用于解决特定问题，如：requests、sh、arrow、pipenv。 框架 Framework 为解决某一特殊领域的问题而设计的具有一定约束性和支撑性的库叫框架，如 Flask、Django、Selenium、Tensorflow。]]></content>
      <categories>
        <category>品味Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构和算法」1.解压序列然后赋值给多个变量]]></title>
    <url>%2F2018%2F01%2F21%2F%E3%80%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E3%80%8D1-%E8%A7%A3%E5%8E%8B%E5%BA%8F%E5%88%97%E7%84%B6%E5%90%8E%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[问题描述有一个元组或序列包含了 N 个元素，如：a_list = [4, 5, 6] 如何将它里面的值解压后同时赋值给 N 个变量呢？ 解决方案任何一个序列（或者可迭代的对象）都可以通过一个简单的赋值语句解压并赋值给多个变量。 不过，需要注意的一个前提就是：变量的个数必须跟序列元素的个数相同。 实例演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 校验把一个「元组」解压并赋值给多个变量def test_unzip_assign_a_tuple(): a_tuple = (1, 2, 3) # 元组 # 把元组解压并赋值给3个变量 t1, t2, t3 = a_tuple assert t1 == 1 assert t2 == 2 assert t3 == 3# 校验把一个「列表」解压并赋值给多个变量def test_unzip_assign_a_list(): # 列表 a_list = [4, 5, 6] # 把列表解压并赋值给3个变量 l1, l2, l3 = a_list assert l1 == 4 assert l2 == 5 assert l3 == 6# 校验把一个「字符串」解压并赋值给多个变量def test_unzip_assign_a_str(): # 字符串 a_str = "fan" # 把字符串解压并赋值给3个变量 s1, s2, s3 = a_str assert s1 == "f" assert s2 == "a" assert s3 == "n"# 校验把一个「混合列表」解压并赋值给多个变量def test_unzip_assign_a_mix_list(): # 混合的列表 mix_list = [4, 5, 'bi', (2018, 1, 21)] # 把混合的列表解压并赋值给4个变量 m1, m2, m3, m4 = mix_list assert m1 == 4 assert m2 == 5 assert m3 == 'bi' assert m4 == (2018, 1, 21) # 把混合的列表解压并赋值给6个变量 m1, m2, m3, (m4, m5, m6) = mix_list assert m1 == 4 assert m2 == 5 assert m3 == 'bi' assert m4 == 2018 assert m5 == 1 assert m6 == 21# 校验把生成器解压并赋值给多个变量def test_unzip_assign_generator(): a_generator = (x * 2 for x in range(3)) g1, g2, g3 = a_generator assert g1 == 0 assert g2 == 2 assert g3 == 4 如果我们只想获取一个列表中的一部分值，其他的值并不关心，怎么办呢？ 123456# 校验只解压一部分值并赋值给变量def test_unzip_part(): # 把不关心的变量使用一些变量占位，这样就可以只获取关心的变量了 _, name, _, gender = [1, "bixiaofan", 2, "帅哥"] assert name == "bixiaofan" assert gender == "帅哥" 注意：必须要保证用于占位的变量在其他地方没有被使用。 小贴示： 这种解压赋值可以用在任何可迭代的对象上，不仅限于列表、元组和字符串，文件对象、迭代器和生成器也是可以的。]]></content>
      <categories>
        <category>PythonCookbook</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[显示命令的帮助手册-man]]></title>
    <url>%2F2018%2F01%2F21%2F%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%AE%E5%8A%A9%E6%89%8B%E5%86%8C-man%2F</url>
    <content type="text"><![CDATA[man 是 manual（手册）的缩写，用来快速查询某个命令的 man-pages（帮助手册页面），并格式化显示。 常用方法:1234567891011# 显示某个命令的帮助手册$ man 命令名# 显示某个命令帮助手册的位置而不是内容：$ man -w 命令名# 显示帮助手册的搜索路径$ man --path# 查询所有包含某个关键字的帮助手册$ man -k 关键字 实例演示:实例1：显示 sort 命令的帮助手册1~$ man sort 命令执行后会进入帮助手册页面，如图所示。帮助手册页面包括了命令的介绍和用法，以及命令选项的说明。 帮助手册页面其实是进入了less查看模式，只要使用less的快捷键操作来查看页面就可以了，非常方便。 实例2：显示man命令查找帮助手册的路径123456~$ man --path/opt/subversion/man:/Library/Frameworks/Python.framework/Versions/2.7/share/man:/usr/local/share/man:/usr/share/man:/opt/X11/share/man:/Applications/Xcode.app/Contents/Developer/usr/share/man:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/share/man# 或 使用man -w,后面不带参数哦。~$ man -w/opt/subversion/man:/Library/Frameworks/Python.framework/Versions/2.7/share/man:/usr/local/share/man:/usr/share/man:/opt/X11/share/man:/Applications/Xcode.app/Contents/Developer/usr/share/man:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/share/man 实例3：显示 ssh 命令的帮助手册地址12~$ man -w ssh/usr/share/man/man1/ssh.1 实例4：查询所有包含 awk 的帮助手册1234~$ man -k awkEnglish(3pm) - use nice English (or awk) names for ugly punctuation variablesa2p(1) - Awk to Perl translatorawk(1) - pattern-directed scanning and processing language]]></content>
      <categories>
        <category>每天一个Linux命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
